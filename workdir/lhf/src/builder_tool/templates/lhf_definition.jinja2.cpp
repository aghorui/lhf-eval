{%- import "macros.jinja2.txt" as macros -%}
/*
 * LHF Datastructure Store
 * =======================
 *
 * This file has been autogenerated from an input configuration and is meant to
 * be extended by the user.
 *
 * Generated for LHF version: {{ lhf_version }}
 * Builder version: {{ blp_version }}
 *
 * Please report any bugs to the project webpage.
 */

{% for item in include_files -%}
#include "{{ item }}"
{%- endfor %}
#include "{{ lhf_header }}"

namespace {{ namespace_value }} {

// LHF_DEFINITIONS

{% for entity in entities %}
{{ macros.lhf_declaration(entity, lhf_namespace, lhf_name) }}
{% endfor %}

// LHF ALIASES

{% for entity in entity_aliases %}
{{ macros.lhf_aliases(entity) }}
{% endfor %}

// STATE

struct {{ state_struct_name }} {
	{% for entity in entities -%}
	{{ entity.name }} {{ entity.var_name }};
	{% endfor %}

	{{ state_struct_name }}():
	{%- for entity in entities -%}
		{{ macros.lhf_constructor(entity) }}{% if not loop.last %},{% endif %}
	{%- endfor -%} {}
};

template<typename LHFT>
struct InterfaceBase {

	template<typename ElementT, typename ElementArgT>
	class ConstIteratorImpl {
		using BaseConstIterator = typename LHFT::PropertySet::const_iterator;
		BaseConstIterator iter;
		const ElementArgT &arg;

	public:
		using iterator_category = std::forward_iterator_tag;
		using value_type = ElementT;
		using difference_type = std::ptrdiff_t;
		using pointer = void;
		using reference = ElementT;

		ConstIteratorImpl(BaseConstIterator iter, const ElementArgT &arg)
			: iter(iter), arg(arg) {}

		const ElementT operator*() const {
			return ElementT(arg, *iter);
		}

		ConstIteratorImpl& operator++() {
			++iter;
			return *this;
		}

		bool operator!=(const ConstIteratorImpl& other) const {
			return iter != other.iter;
		}
	};

	using key_type = typename LHFT::PropertyElement::InterfaceKeyType;
	using value_type = typename LHFT::PropertyElement::InterfaceValueType;
	using size_type = typename LHFT::PropertySet::size_type;

	using Index = typename LHFT::Index;

	LHFT &lhf;
	const Index set_index;

	InterfaceBase(LHFT &lhf, Index set_index = Index()): lhf(lhf), set_index(set_index) {}

	bool operator<(const InterfaceBase &b) const {
		return set_index < b.set_index;
	}

	bool operator==(const InterfaceBase &b) const {
		return set_index == b.set_index;
	}

	bool is_empty() const {
		return set_index.is_empty();
	}

	bool contains(const key_type &k) const {
		return lhf.contains(set_index, k);
	}

	const typename LHFT::PropertySet &get_value() const {
		return lhf.get_value(set_index);
	}

	std::size_t size() const {
		return lhf.size_of(set_index);
	}
};

// INTERFACES

{% for entity in entities %}
{{ macros.lhf_interface(entity, state_struct_name) }}
{% endfor %}

// INTERFACE ALIASES

{% for entity in interface_aliases %}
{{ macros.interface_aliases(entity) }}
{% endfor %}

// STORAGE STRUCT
struct {{ store_struct_name }} {
	{{ state_struct_name }} state;

{% for entity in entities %}
	{{ entity.interface_name }} register_{{ entity.var_name }}({{ entity.name }}::PropertySet &&g) {
		return {{ entity.interface_name }}(state, state.{{ entity.var_name }}.register_set(g));
	}

	{{ entity.interface_name }} register_{{ entity.var_name }}({{ entity.name }}::PropertySet &g) {
		return {{ entity.interface_name }}(state, state.{{ entity.var_name }}.register_set(g));
	}

	{{ entity.interface_name }} register_{{ entity.var_name }}_single({{ entity.name }}::PropertyElement &&g) {
		return {{ entity.interface_name }}(state, state.{{ entity.var_name }}.register_set_single(g));
	}

	{{ entity.interface_name }} register_{{ entity.var_name }}_single({{ entity.name }}::PropertyElement &g) {
		return {{ entity.interface_name }}(state, state.{{ entity.var_name }}.register_set_single(g));
	}

{% endfor %}
};

};