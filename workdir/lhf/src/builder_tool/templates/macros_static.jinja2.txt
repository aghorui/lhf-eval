{% macro lhf_nesting(entity, lhf_namespace) -%}
{%- if entity.nesting_type == NestingType.NONE -%}
	{{ lhf_namespace }}::NestingNone<{{ entity.type_name }}>
{%- elif entity.nesting_type == NestingType.BASE -%}
	{{ lhf_namespace }}::NestingBase<{{ entity.type_name }}, {{ entity.nesting_elems | join(', ') }}>
{%- elif entity.nesting_type == NestingType.IMPLICIT -%}
	{{ lhf_namespace }}::NestingNone<{{ entity.type_name }}>
{%- else -%}
	{{ raise("Unhandled Nesting Type: " + entity.nesting_type) }}
{%- endif -%}
{%- endmacro %}

{% macro lhf_declaration(entity, lhf_namespace, lhf_name) %}
struct {{ entity.name }} : {{ lhf_namespace }}::{{ lhf_name }}<
	{{ entity.type_name }},
	{{ entity.less }},
	{{ entity.hash }},
	{{ entity.equal }},
	{{ entity.print }},
	{{ lhf_nesting(entity, lhf_namespace) }}
	> {
	explicit {{ entity.name }}(RefList reflist): {{ lhf_name }}(reflist) {}

	// LHF-LEVEL COMPONENTS GO HERE
};
{% endmacro %}

{% macro lhf_aliases(item) %}
using {{ item.from }} = {{ item.to }};
{% endmacro %}

{%- macro lhf_constructor(entity) -%}
	{ {{ entity.dependencies | join(', ') }} }
{%- endmacro -%}

{% macro lhf_interface_binary_operation(entity, operation) %}
	{{ entity.interface_name }} {{ operation }}(const {{ entity.interface_name }} &b) {
		return {{ entity.interface_name }}({{ entity.var_name }}.{{operation}}(set_index, b.set_index));
	}
{% endmacro %}

{% macro lhf_interface(entity, state_struct_name) %}
struct {{ entity.interface_name }} : InterfaceBase<{{ entity.name }}> {
	struct Element {
		const {{ entity.name }}::PropertyElement &p;
		Element(const {{ entity.name }}::PropertyElement &p): p(p) {}

		// ELEMENT INTERFACE GOES HERE
	};

	using ConstIterator = ConstIteratorImpl<Element>;

	{{ entity.interface_name }}(Index set_index = Index()):
		InterfaceBase(set_index) {}

	// CONTAINER INTERFACE GOES HERE

	{{ lhf_interface_binary_operation(entity, "set_union") }}
	{{ lhf_interface_binary_operation(entity, "set_difference") }}
	{{ lhf_interface_binary_operation(entity, "set_intersection") }}

	{{ entity.interface_name }} set_insert_single(const {{ entity.name }}::PropertyElement &p) {
		return {{ entity.interface_name }}({{ entity.var_name }}.set_insert_single(set_index, p));
	}

	{{ entity.interface_name }} set_remove_single(const {{ entity.name }}::PropertyElement &p) {
		return {{ entity.interface_name }}({{ entity.var_name }}.set_remove_single(set_index, p));
	}

	bool contains(const {{ entity.name }}::PropertyElement &p) {
		return {{ entity.var_name }}.contains(set_index, p);
	}

	const typename {{ entity.name }}::PropertySet &get_value() const {
		return {{ entity.var_name }}.get_value(set_index);
	}

	std::size_t size() const {
		return {{ entity.var_name }}.size_of(set_index);
	}

	ConstIterator begin() const {
		return ConstIterator(get_value().begin());
	}

	ConstIterator end() const {
		return ConstIterator(get_value().end());
	}
};
{% endmacro %}

{% macro interface_aliases(item) %}
using {{ item.from }} = {{ item.to }};
{%  endmacro %}