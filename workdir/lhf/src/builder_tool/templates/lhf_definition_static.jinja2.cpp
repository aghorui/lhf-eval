{%- import "macros_static.jinja2.txt" as macros -%}
/*
 * LHF Datastructure Store
 * =======================
 *
 * This file has been autogenerated from an input configuration and is meant to
 * be extended by the user.
 *
 * Generated for LHF version: {{ lhf_version }}
 * Builder version: {{ blp_version }}
 *
 * Please report any bugs to the project webpage.
 */

{% for item in include_files -%}
#include "{{ item }}"
{%- endfor %}
#include "{{ lhf_header }}"

namespace {{ namespace_value }} {

// LHF_DEFINITIONS

{% for entity in entities %}
{{ macros.lhf_declaration(entity, lhf_namespace, lhf_name) }}
{% endfor %}

// LHF ALIASES

{% for entity in entity_aliases %}
{{ macros.lhf_aliases(entity) }}
{% endfor %}

// GLOBAL STATE

{% for entity in entities -%}
static {{ entity.name }} {{ entity.var_name }}({{ macros.lhf_constructor(entity) }});
{% endfor %}

// INTERFACES

template<typename LHFT>
struct InterfaceBase {

	template<typename ElementT>
	class ConstIteratorImpl {
		using BaseConstIterator = typename LHFT::PropertySet::const_iterator;
		BaseConstIterator iter;

	public:
		using iterator_category = std::forward_iterator_tag;
		using value_type = ElementT;
		using difference_type = std::ptrdiff_t;
		using pointer = void;
		using reference = ElementT;

		ConstIteratorImpl(BaseConstIterator iter)
			: iter(iter) {}

		const ElementT operator*() const {
			return ElementT(*iter);
		}

		ConstIteratorImpl& operator++() {
			++iter;
			return *this;
		}

		bool operator!=(const ConstIteratorImpl& other) const {
			return iter != other.iter;
		}
	};

	using key_type = typename LHFT::PropertyElement::InterfaceKeyType;
	using value_type = typename LHFT::PropertyElement::InterfaceValueType;
	using size_type = typename LHFT::PropertySet::size_type;

	using Index = typename LHFT::Index;

	const Index set_index;

	InterfaceBase(Index set_index = Index()): set_index(set_index) {}

	bool operator<(const InterfaceBase &b) const {
		return set_index < b.set_index;
	}

	bool operator==(const InterfaceBase &b) const {
		return set_index == b.set_index;
	}

	bool is_empty() const {
		return set_index.is_empty();
	}
};

// INTERFACES

{% for entity in entities %}
{{ macros.lhf_interface(entity, state_struct_name) }}
{% endfor %}

// INTERFACE ALIASES

{% for entity in interface_aliases %}
{{ macros.interface_aliases(entity) }}
{% endfor %}

};